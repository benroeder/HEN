*** click-git-20080715.orig/elements/linuxmodule/polldevice.cc	2009-04-30 15:51:25.000000000 +0100
--- click-git-20080715/elements/linuxmodule/polldevice.cc	2009-04-30 12:49:28.000000000 +0100
***************
*** 76,89 ****
  {
      _burst = 8;
      _headroom = 64;
      if (AnyDevice::configure_keywords(conf, errh, true) < 0
  	|| cp_va_kparse(conf, this, errh,
  			"DEVNAME", cpkP+cpkM, cpString, &_devname,
  			"BURST", cpkP, cpUnsigned, &_burst,
  			"HEADROOM", 0, cpUnsigned, &_headroom,
  			cpEnd) < 0)
  	return -1;
!     
  #if HAVE_LINUX_POLLING
      if (find_device(&poll_device_map, errh) < 0)
  	return -1;
--- 76,91 ----
  {
      _burst = 8;
      _headroom = 64;
+     _queue = 0;
      if (AnyDevice::configure_keywords(conf, errh, true) < 0
  	|| cp_va_kparse(conf, this, errh,
  			"DEVNAME", cpkP+cpkM, cpString, &_devname,
  			"BURST", cpkP, cpUnsigned, &_burst,
  			"HEADROOM", 0, cpUnsigned, &_headroom,
+ 			"ADDRESS", 0, cpEthernetAddress, &_mac.ether_shost,
  			cpEnd) < 0)
  	return -1;
!     click_chatter("polldevice for device %s",_devname.c_str());
  #if HAVE_LINUX_POLLING
      if (find_device(&poll_device_map, errh) < 0)
  	return -1;
***************
*** 102,118 ****
  int
  PollDevice::initialize(ErrorHandler *errh)
  {
      if (AnyDevice::initialize_keywords(errh) < 0)
  	return -1;
      
  #if HAVE_LINUX_POLLING
      // check for duplicate readers
      if (ifindex() >= 0) {
  	void *&used = router()->force_attachment("device_reader_" + String(ifindex()));
  	if (used)
  	    return errh->error("duplicate reader for device '%s'", _devname.c_str());
  	used = this;
! 
  	if (!router()->attachment("device_writer_" + String(ifindex())))
  	    errh->warning("no ToDevice(%s) in configuration\n(\
  Generally, you will get bad performance from PollDevice unless\n\
--- 104,125 ----
  int
  PollDevice::initialize(ErrorHandler *errh)
  {
+ 
+     click_chatter("polldevice initalise for device %s",_devname.c_str());
      if (AnyDevice::initialize_keywords(errh) < 0)
  	return -1;
      
  #if HAVE_LINUX_POLLING
      // check for duplicate readers
+     
+ 
      if (ifindex() >= 0) {
  	void *&used = router()->force_attachment("device_reader_" + String(ifindex()));
+ 	
  	if (used)
  	    return errh->error("duplicate reader for device '%s'", _devname.c_str());
  	used = this;
! 	
  	if (!router()->attachment("device_writer_" + String(ifindex())))
  	    errh->warning("no ToDevice(%s) in configuration\n(\
  Generally, you will get bad performance from PollDevice unless\n\
***************
*** 125,130 ****
--- 132,138 ----
  	_dev->poll_on(_dev);
  	if (_dev->polling != 2)
  	    return errh->error("PollDevice detected wrong version of polling patch");
+ 	//_dev->click_mac(_dev,&_queue,(u8*)&_mac.ether_shost);
      }
  
      ScheduleInfo::initialize_task(this, &_task, _dev != 0, errh);
***************
*** 198,206 ****
  # endif
  
    SET_STATS(low00, low10, time_now);
! 
    got = _burst;
!   skb_list = _dev->rx_poll(_dev, &got);
  
  # if CLICK_DEVICE_STATS
    if (got > 0 || _activations > 0) {
--- 206,214 ----
  # endif
  
    SET_STATS(low00, low10, time_now);
!   //_dev->click_mac(_dev,&_queue,(u8*)&_mac.ether_shost);
    got = _burst;
!   skb_list = _dev->rx_poll(_dev, &_queue, &got);
  
  # if CLICK_DEVICE_STATS
    if (got > 0 || _activations > 0) {
***************
*** 215,221 ****
  
    int nskbs = got;
    if (got == 0)
!     nskbs = _dev->rx_refill(_dev, 0);
  
    if (nskbs > 0) {
      /*
--- 223,229 ----
  
    int nskbs = got;
    if (got == 0)
!     nskbs = _dev->rx_refill(_dev, &_queue, 0);
  
    if (nskbs > 0) {
      /*
***************
*** 234,240 ****
  	              _perfcnt1_allocskb, _perfcnt2_allocskb, _time_allocskb);
  # endif
  
!     nskbs = _dev->rx_refill(_dev, &new_skbs);
  
  # if CLICK_DEVICE_STATS
      if (_activations > 0) 
--- 242,248 ----
  	              _perfcnt1_allocskb, _perfcnt2_allocskb, _time_allocskb);
  # endif
  
!     nskbs = _dev->rx_refill(_dev, &_queue, &new_skbs);
  
  # if CLICK_DEVICE_STATS
      if (_activations > 0) 
*** click-git-20080715.orig/elements/linuxmodule/polldevice.hh	2009-04-30 15:51:25.000000000 +0100
--- click-git-20080715/elements/linuxmodule/polldevice.hh	2009-04-23 15:38:28.000000000 +0100
***************
*** 92,97 ****
--- 92,98 ----
  =a FromDevice, ToDevice, FromHost, ToHost */
  
  #include "elements/linuxmodule/anydevice.hh"
+ #include <clicknet/ether.h>
  
  class PollDevice : public AnyTaskDevice { public:
    
***************
*** 143,153 ****
      
    uint32_t _buffers_reused;
  
!  private:
! 
      unsigned _burst;
      unsigned _headroom;
! 
  };
  
  #endif 
--- 144,154 ----
      
    uint32_t _buffers_reused;
  
!  protected:
!     int _queue;
      unsigned _burst;
      unsigned _headroom;
!     click_ether _mac;
  };
  
  #endif 
*** click-git-20080715.orig/elements/linuxmodule/subpolldevice.cc	1970-01-01 01:00:00.000000000 +0100
--- click-git-20080715/elements/linuxmodule/subpolldevice.cc	2009-04-30 12:47:16.000000000 +0100
***************
*** 0 ****
--- 1,200 ----
+ // -*- mode: c++; c-basic-offset: 4 -*-
+ /*
+  * polldevice.{cc,hh} -- element steals packets from Linux devices by polling.
+  * Benjie Chen, Eddie Kohler
+  *
+  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
+  * Copyright (c) 2000 Mazu Networks, Inc.
+  * Copyright (c) 2001 International Computer Science Institute
+  * Copyright (c) 2004 Regents of the University of California
+  *
+  * Permission is hereby granted, free of charge, to any person obtaining a
+  * copy of this software and associated documentation files (the "Software"),
+  * to deal in the Software without restriction, subject to the conditions
+  * listed in the Click LICENSE file. These conditions include: you must
+  * preserve this copyright notice, and you cannot mention the copyright
+  * holders in advertising related to the Software without their permission.
+  * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+  * notice is a summary of the Click LICENSE file; the license in that file is
+  * legally binding.
+  */
+ 
+ #include <click/config.h>
+ #include <click/glue.hh>
+ #include "subpolldevice.hh"
+ #include "polldevice.hh"
+ #include "fromdevice.hh"
+ #include "todevice.hh"
+ #include <click/error.hh>
+ #include <click/confparse.hh>
+ #include <click/router.hh>
+ #include <click/skbmgr.hh>
+ #include <click/standard/scheduleinfo.hh>
+ 
+ #include <click/cxxprotect.h>
+ CLICK_CXX_PROTECT
+ #include <linux/netdevice.h>
+ #if __i386__
+ #include <asm/msr.h>
+ #endif
+ CLICK_CXX_UNPROTECT
+ #include <click/cxxunprotect.h>
+ 
+ /* for hot-swapping */
+ static AnyDeviceMap poll_device_map;
+ static struct notifier_block device_notifier;
+ extern "C" {
+ static int device_notifier_hook(struct notifier_block *nb, unsigned long val, void *v);
+ }
+ 
+ void
+ SubPollDevice::static_initialize()
+ {
+     poll_device_map.initialize();
+     device_notifier.notifier_call = device_notifier_hook;
+     device_notifier.priority = 1;
+     device_notifier.next = 0;
+     register_netdevice_notifier(&device_notifier);
+ }
+ 
+ void
+ SubPollDevice::static_cleanup()
+ {
+     unregister_netdevice_notifier(&device_notifier);
+ }
+ 
+ SubPollDevice::SubPollDevice()
+ {
+ }
+ 
+ SubPollDevice::~SubPollDevice()
+ {
+ }
+ 
+ 
+ int
+ SubPollDevice::configure(Vector<String> &conf, ErrorHandler *errh)
+ {
+     _burst = 8;
+     _headroom = 64;
+     if (AnyDevice::configure_keywords(conf, errh, true) < 0
+ 	|| cp_va_kparse(conf, this, errh,
+ 			"DEVNAME", cpkP+cpkM, cpString, &_devname,
+ 			"BURST", cpkP, cpUnsigned, &_burst,
+ 			"HEADROOM", 0, cpUnsigned, &_headroom,
+ 			"QUEUE", 0, cpInteger, &_queue,
+ 			"ADDRESS", 0, cpEthernetAddress, &_mac.ether_shost,
+ 			cpEnd) < 0)
+ 	return -1;
+ 
+     click_chatter("subpolldevice for device %s",_devname.c_str());
+     
+ #if HAVE_LINUX_POLLING
+     if (find_device(&poll_device_map, errh) < 0)
+ 	return -1;
+     if (_dev && (!_dev->poll_on || _dev->polling < 0))
+ 	return errh->error("device '%s' not pollable, use FromDevice instead", _devname.c_str());
+ #endif
+ 
+     return 0;
+ }
+ 
+ 
+ /*
+  * Use Linux interface for polling, added by us, in include/linux/netdevice.h,
+  * to poll devices.
+  */
+ int
+ SubPollDevice::initialize(ErrorHandler *errh)
+ {
+     click_chatter("subpolldevice initalise for device %s",_devname.c_str());
+ 
+     if (AnyDevice::initialize_keywords(errh) < 0)
+ 	return -1;
+     
+ #if HAVE_LINUX_POLLING
+     // check for duplicate readers
+     
+ 
+     if (ifindex() >= 0) {
+ 	void *&used = router()->force_attachment("device_reader_" + String(ifindex()));
+     
+ 	//if (!used)
+ 	//    return errh->error("A poll device for device is required for a subqueue");
+     }
+     if (_dev && !_dev->polling) {
+ 	/* turn off interrupt if interrupts weren't already off */
+ 	//_dev->poll_mon(_dev,&_queue);
+ 	if (_dev->polling != 2)
+ 	    return errh->error("SubPollDevice detected wrong version of polling patch");
+ 
+     }
+     if (_dev && _dev->polling) {
+ 	click_chatter("Trying to set mac address for device %d",_queue);
+ 	_dev->click_mac(_dev,&_queue,(u8*)&_mac.ether_shost);
+     }
+     ScheduleInfo::initialize_task(this, &_task, _dev != 0, errh);
+ #if HAVE_STRIDE_SCHED
+     // user specifies max number of tickets; we start with default
+     _max_tickets = _task.tickets();
+     _task.set_tickets(Task::DEFAULT_TICKETS);
+ #endif
+ 
+     reset_counts();
+     
+ #else
+     errh->warning("can't get packets: not compiled with polling extensions");
+ #endif
+ 
+     return 0;
+ }
+ 
+ 
+ extern "C" {
+ static int
+ device_notifier_hook(struct notifier_block *nb, unsigned long flags, void *v)
+ {
+ #ifdef NETDEV_GOING_DOWN
+     if (flags == NETDEV_GOING_DOWN)
+         flags = NETDEV_DOWN;
+ #endif
+     if (flags == NETDEV_DOWN || flags == NETDEV_UP || flags == NETDEV_CHANGE) {
+         bool exists = (flags != NETDEV_UP);
+         net_device *dev = (net_device *)v;
+         Vector<AnyDevice *> es;
+         poll_device_map.lock(true);
+         poll_device_map.lookup_all(dev, exists, es);
+         for (int i = 0; i < es.size(); i++)
+             ((PollDevice *)(es[i]))->change_device(flags == NETDEV_DOWN ? 0 : dev);
+         poll_device_map.unlock(true);
+     }
+     return 0;
+ }
+ }
+ 
+ 
+ void
+ SubPollDevice::cleanup(CleanupStage)
+ {
+ #if HAVE_LINUX_POLLING
+ 	net_device *had_dev = _dev;
+ 
+ 	// call clear_device first so we can check poll_device_map for
+ 	// other users
+ 	clear_device(&poll_device_map);
+ 
+ 	poll_device_map.lock(false);
+ 	if (had_dev && had_dev->polling > 0 && !poll_device_map.lookup(had_dev, 0))
+ 	    had_dev->poll_off(had_dev);
+ 	poll_device_map.unlock(false);
+ #endif
+ 
+ }
+ void
+ SubPollDevice::change_device(net_device *dev)
+ {
+     // need to do something here
+ }
+ 
+ ELEMENT_REQUIRES(PollDevice linuxmodule)
+ EXPORT_ELEMENT(SubPollDevice)
*** click-git-20080715.orig/elements/linuxmodule/subpolldevice.hh	1970-01-01 01:00:00.000000000 +0100
--- click-git-20080715/elements/linuxmodule/subpolldevice.hh	2009-04-23 15:38:28.000000000 +0100
***************
*** 0 ****
--- 1,157 ----
+ #ifndef CLICK_SUBPOLLDEVICE_HH
+ #define CLICK_SUBPOLLDEVICE_HH
+ 
+ /*
+ =c
+ 
+ SubPollDevice(DEVNAME [, I<keywords> PROMISC, BURST, TIMESTAMP...])
+ 
+ =s netdevices
+ 
+ polls packets from network device (kernel)
+ 
+ =d
+ 
+ Poll packets received by the Linux network interface named DEVNAME. Packets
+ will be pushed to output 0. The packets include the link-level header. DEVNAME
+ may also be an Ethernet address, in which case SubPollDevice searches for a
+ device with that address.
+ 
+ Each time SubPollDevice is scheduled, it emits at most BURST packets. By default,
+ BURST is 8.
+ 
+ This element is only available in the Linux kernel module.
+ 
+ Keyword arguments are:
+ 
+ =over 8
+ 
+ =item PROMISC
+ 
+ Boolean.  If true, the device is put into promiscuous mode while FromDevice is
+ active.  Default is false.
+ 
+ =item BURST
+ 
+ Unsigned integer.  Sets the BURST parameter.
+ 
+ =item TIMESTAMP
+ 
+ Boolean.  If true, then ensure that received packets have correctly-set
+ timestamp annotations.  Default is true.
+ 
+ =item QUIET
+ 
+ Boolean.  If true, then suppress device up/down messages.  Default is false.
+ 
+ =item HEADROOM
+ 
+ Unsigned.  Amount of extra headroom to request on each packet.  Default is 64.
+ 
+ =item ALLOW_NONEXISTENT
+ 
+ Allow nonexistent devices. If true, and no device named DEVNAME exists when
+ the router is initialized, then SubPollDevice will report a warning (rather than
+ an error). Later, while the router is running, if a device named DEVNAME
+ appears, SubPollDevice will seamlessly begin emitting its packets. Default is
+ false.
+ 
+ =item UP_CALL
+ 
+ Write handler.  If supplied, this handler is called when the device or link
+ comes up.
+ 
+ =item DOWN_CALL
+ 
+ Write handler.  If supplied, this handler is called when the device or link
+ goes down.
+ 
+ =back
+ 
+ =n
+ 
+ Linux won't see any packets from the device. If you want Linux to process
+ packets, you should hand them to ToHost. Also, if you would like to send
+ packets while using SubPollDevice, you should also define a ToDevice on the same
+ device.
+ 
+ This element can only be used with devices that support the Click polling
+ extension. We have written polling patches for the Tulip Ethernet driver.
+ 
+ Linux device drivers, and thus FromDevice, should set packets' timestamp,
+ packet-type, and device annotations.
+ 
+ =h count read-only
+ 
+ Returns the number of packets SubPollDevice has received from the input card.
+ 
+ =h reset_counts write-only
+ 
+ Resets C<count> counter to zero when written.
+ 
+ =a FromDevice, ToDevice, FromHost, ToHost */
+ 
+ #include "elements/linuxmodule/anydevice.hh"
+ #include "elements/linuxmodule/polldevice.hh"
+ #include <clicknet/ether.h>
+ 
+ class SubPollDevice : public PollDevice { public:
+   
+   SubPollDevice();
+   ~SubPollDevice();
+ 
+   static void static_initialize();
+   static void static_cleanup();
+   
+   const char *class_name() const	{ return "SubPollDevice"; }
+   //const char *port_count() const	{ return PORTS_0_1; }
+   //const char *processing() const	{ return PUSH; }
+   
+   int configure_phase() const		{ return CONFIGURE_PHASE_POLLDEVICE + 1; }
+   int configure(Vector<String> &, ErrorHandler *);
+   int initialize(ErrorHandler *);
+   void cleanup(CleanupStage);
+   //void add_handlers();
+ 
+   void change_device(net_device *);
+   /* process a packet. return 0 if not wanted after all. */
+   //int got_skb(struct sk_buff *);
+ 
+   //bool run_task(Task *);
+ 
+   //void reset_counts();
+   
+   //uint32_t _npackets;
+ #if CLICK_DEVICE_STATS
+   //uint64_t _time_poll;
+   //uint64_t _time_allocskb;
+   //uint64_t _time_refill;
+ 
+   //uint64_t _perfcnt1_poll;
+   //uint64_t _perfcnt1_refill;
+   //uint64_t _perfcnt1_allocskb;
+   //uint64_t _perfcnt1_pushing;
+   //uint64_t _perfcnt2_poll;
+   //uint64_t _perfcnt2_refill;
+   //uint64_t _perfcnt2_allocskb;
+   //uint64_t _perfcnt2_pushing;
+ 
+   //uint32_t _empty_polls;
+   //uint32_t _activations;
+ #endif
+ #if CLICK_DEVICE_THESIS_STATS || CLICK_DEVICE_STATS
+   //click_cycles_t _push_cycles;
+ #endif
+     
+   //uint32_t _buffers_reused;
+ 
+   // private:
+   //int _queue;
+   //bool _subqueue;
+   //unsigned _burst;
+   //unsigned _headroom;
+   //click_ether _mac;
+ };
+ 
+ #endif 
+ 
*** click-git-20080715.orig/elements/linuxmodule/subtodevice.cc	1970-01-01 01:00:00.000000000 +0100
--- click-git-20080715/elements/linuxmodule/subtodevice.cc	2009-04-30 12:48:33.000000000 +0100
***************
*** 0 ****
--- 1,579 ----
+ // -*- mode: c++; c-basic-offset: 4 -*-
+ /*
+  * todevice.{cc,hh} -- element sends packets to Linux devices.
+  * Robert Morris
+  * Eddie Kohler: register once per configuration
+  * Benjie Chen: polling
+  *
+  * Copyright (c) 1999-2000 Massachusetts Institute of Technology
+  * Copyright (c) 2000 Mazu Networks, Inc.
+  * Copyright (c) 2001 International Computer Science Institute
+  * Copyright (c) 2005-2007 Regents of the University of California
+  *
+  * Permission is hereby granted, free of charge, to any person obtaining a
+  * copy of this software and associated documentation files (the "Software"),
+  * to deal in the Software without restriction, subject to the conditions
+  * listed in the Click LICENSE file. These conditions include: you must
+  * preserve this copyright notice, and you cannot mention the copyright
+  * holders in advertising related to the Software without their permission.
+  * The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
+  * notice is a summary of the Click LICENSE file; the license in that file is
+  * legally binding.
+  */
+ 
+ #include <click/config.h>
+ #include <click/glue.hh>
+ #include "polldevice.hh"
+ #include "todevice.hh"
+ #include "subtodevice.hh"
+ #include <click/error.hh>
+ #include <click/etheraddress.hh>
+ #include <click/confparse.hh>
+ #include <click/router.hh>
+ #include <click/standard/scheduleinfo.hh>
+ 
+ #include <click/cxxprotect.h>
+ CLICK_CXX_PROTECT
+ #include <net/pkt_sched.h>
+ #if __i386__
+ #include <asm/msr.h>
+ #endif
+ CLICK_CXX_UNPROTECT
+ #include <click/cxxunprotect.h>
+ 
+ /* for watching when devices go offline */
+ static AnyDeviceMap to_device_map;
+ static struct notifier_block device_notifier;
+ extern "C" {
+ static int device_notifier_hook(struct notifier_block *nb, unsigned long val, void *v);
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+ static struct notifier_block tx_notifier;
+ static int registered_tx_notifiers;
+ static int tx_notifier_hook(struct notifier_block *nb, unsigned long val, void *v);
+ #endif
+ }
+ 
+ void
+ SubToDevice::static_initialize()
+ {
+     to_device_map.initialize();
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+     tx_notifier.notifier_call = tx_notifier_hook;
+     tx_notifier.priority = 1;
+     tx_notifier.next = 0;
+ #endif
+     device_notifier.notifier_call = device_notifier_hook;
+     device_notifier.priority = 1;
+     device_notifier.next = 0;
+     register_netdevice_notifier(&device_notifier);
+ 
+ }
+ 
+ void
+ SubToDevice::static_cleanup()
+ {
+     unregister_netdevice_notifier(&device_notifier);
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+     if (registered_tx_notifiers)
+ 	unregister_net_tx(&tx_notifier);
+ #endif
+ }
+ 
+ inline void
+ SubToDevice::tx_wake_queue(net_device *dev) 
+ {
+     //click_chatter("%{element}::%s for dev %s\n", this, __func__, dev->name);
+     _task.reschedule();
+ }
+ 
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+ extern "C" {
+ static int
+ tx_notifier_hook(struct notifier_block *nb, unsigned long val, void *v) 
+ {
+     struct net_device *dev = (struct net_device *)v;
+     if (!dev)
+ 	return 0;
+     Vector<AnyDevice *> es;
+     to_device_map.lock(false);
+     to_device_map.lookup_all(dev, true, es);
+     for (int i = 0; i < es.size(); i++) 
+ 	((SubToDevice *)(es[i]))->tx_wake_queue(dev);
+     to_device_map.unlock(false);
+     return 0;
+ }
+ }
+ #endif
+ 
+ SubToDevice::SubToDevice()
+     : _dev_idle(0), _rejected(0), _hard_start(0), _no_pad(false)
+ {
+ }
+ 
+ SubToDevice::~SubToDevice()
+ {
+ }
+ 
+ 
+ int
+ SubToDevice::configure(Vector<String> &conf, ErrorHandler *errh)
+ {
+     _burst = 16;
+     if (AnyDevice::configure_keywords(conf, errh, false) < 0
+ 	|| cp_va_kparse(conf, this, errh,
+ 			"DEVNAME", cpkP+cpkM, cpString, &_devname,
+ 			"BURST", cpkP, cpUnsigned, &_burst,
+ 			"NO_PAD", 0, cpBool, &_no_pad,
+ 			"QUEUE", 0, cpInteger, &_queue,
+ 			cpEnd) < 0)
+ 	return -1;
+     return find_device(&to_device_map, errh);
+ }
+ 
+ int
+ SubToDevice::initialize(ErrorHandler *errh)
+ {
+     if (AnyDevice::initialize_keywords(errh) < 0)
+ 	return -1;
+     
+ #ifndef HAVE_CLICK_KERNEL
+     errh->warning("not compiled for a Click kernel");
+ #endif
+ 
+     // check for duplicate writers
+     if (ifindex() >= 0) {
+ 	void *&used = router()->force_attachment("device_writer_" + String(ifindex()));
+ 	//if (used)
+ 	//    return errh->error("duplicate writer for device '%s'", _devname.c_str());
+ 	used = this;
+     }
+ 
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+     if (!registered_tx_notifiers) {
+ 	tx_notifier.next = 0;
+ 	register_net_tx(&tx_notifier);
+     }
+     registered_tx_notifiers++;
+ #endif
+ 
+     ScheduleInfo::initialize_task(this, &_task, _dev != 0, errh);
+     _signal = Notifier::upstream_empty_signal(this, 0, &_task);
+ 
+ #if HAVE_STRIDE_SCHED
+     // user specifies max number of tickets; we start with default
+     _max_tickets = _task.tickets();
+     _task.set_tickets(Task::DEFAULT_TICKETS);
+ #endif
+     _dev->unlock_queue(_dev,&_queue,smp_processor_id());
+     reset_counts();
+     return 0;
+ }
+ 
+ void
+ SubToDevice::reset_counts()
+ {
+   _npackets = 0;
+   
+   _busy_returns = 0;
+   _too_short = 0;
+   _runs = 0;
+   _pulls = 0;
+ #if CLICK_DEVICE_STATS
+   _activations = 0;
+   _time_clean = 0;
+   _time_freeskb = 0;
+   _time_queue = 0;
+   _perfcnt1_pull = 0;
+   _perfcnt1_clean = 0;
+   _perfcnt1_freeskb = 0;
+   _perfcnt1_queue = 0;
+   _perfcnt2_pull = 0;
+   _perfcnt2_clean = 0;
+   _perfcnt2_freeskb = 0;
+   _perfcnt2_queue = 0;
+ #endif
+ #if CLICK_DEVICE_THESIS_STATS || CLICK_DEVICE_STATS
+   _pull_cycles = 0;
+ #endif
+ }
+ 
+ void
+ SubToDevice::cleanup(CleanupStage stage)
+ {
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+     if (stage >= CLEANUP_INITIALIZED) {
+ 	registered_tx_notifiers--;
+ 	if (registered_tx_notifiers == 0)
+ 	    unregister_net_tx(&tx_notifier);
+     }
+ #endif
+     clear_device(&to_device_map);
+ }
+ 
+ /*
+  * Problem: Linux drivers aren't required to
+  * accept a packet even if they've marked themselves
+  * as idle. What do we do with a rejected packet?
+  */
+ 
+ #if LINUX_VERSION_CODE < 0x020400
+ # define netif_queue_stopped(dev)	((dev)->tbusy)
+ # define netif_wake_queue(dev)		mark_bh(NET_BH)
+ #endif
+ 
+ bool
+ SubToDevice::run_task(Task *)
+ {
+     int busy = 0;
+     int sent = 0;
+ 
+     _runs++;
+ 
+ #if LINUX_VERSION_CODE >= 0x020400
+ # if HAVE_NETIF_TX_LOCK
+     //int ok = spin_trylock_bh(&_dev->_xmit_lock);
+     int ok = _dev->lock_queue(_dev,&_queue,smp_processor_id());
+ 
+     if (likely(ok)) {
+ 	
+ 	//	_dev->xmit_lock_owner = smp_processor_id();
+ 	//else {
+     	//_task.fast_reschedule();
+     	//return false;
+ 	//}
+ # else
+     local_bh_disable();
+     if (!spin_trylock(&_dev->xmit_lock)) {
+ 	local_bh_enable();
+ 	_task.fast_reschedule();
+ 	return false;
+     }
+     _dev->xmit_lock_owner = smp_processor_id();
+ # endif
+ #endif
+ 
+ #if CLICK_DEVICE_STATS
+     unsigned low00, low10;
+     uint64_t time_now;
+     SET_STATS(low00, low10, time_now);
+ #endif
+     
+ #if HAVE_LINUX_POLLING
+     bool is_polling = (_dev->polling > 0);
+     struct sk_buff *clean_skbs;
+     if (is_polling)
+ 	{
+ 	clean_skbs = _dev->tx_clean(_dev,&_queue);
+ 	//click_chatter("got clean skbs %d\n",clean_skbs);
+ 	}
+     else
+ 	clean_skbs = 0;
+ #endif
+   
+     /* try to send from click */
+     while (sent < _burst && (busy = netif_queue_stopped(_dev)) == 0) {
+ #if CLICK_DEVICE_THESIS_STATS && !CLICK_DEVICE_STATS
+ 	click_cycles_t before_pull_cycles = click_get_cycles();
+ #endif
+ 
+ 	_pulls++;
+ 
+ 	Packet *p = input(0).pull();
+ 	if (!p)
+ 	    break;
+ 
+ 	_npackets++;
+ #if CLICK_DEVICE_THESIS_STATS && !CLICK_DEVICE_STATS
+ 	_pull_cycles += click_get_cycles() - before_pull_cycles - CLICK_CYCLE_COMPENSATION;
+ #endif
+ 
+ 	GET_STATS_RESET(low00, low10, time_now, 
+ 			_perfcnt1_pull, _perfcnt2_pull, _pull_cycles);
+ 
+ 	busy = queue_packet(p);
+ 
+ 	GET_STATS_RESET(low00, low10, time_now, 
+ 			_perfcnt1_queue, _perfcnt2_queue, _time_queue);
+ 
+ 	if (busy)
+ 	    break;
+ 	sent++;
+     }
+ 
+ #if HAVE_LINUX_POLLING
+     if (is_polling && sent > 0)
+ 	_dev->tx_eob(_dev);
+ 
+     // If Linux tried to send a packet, but saw tbusy, it will
+     // have left it on the queue. It'll just sit there forever
+     // (or until Linux sends another packet) unless we poke
+     // net_bh(), which calls qdisc_restart(). We are not allowed
+     // to call qdisc_restart() ourselves, outside of net_bh().
+     if (is_polling && !busy && _dev->qdisc->q.qlen) {
+ 	_dev->tx_eob(_dev);
+ 	//netif_wake_queue(_dev);
+     }
+ #endif
+ 
+ #if CLICK_DEVICE_STATS
+     if (sent > 0)
+ 	_activations++;
+ #endif
+ 
+     if (busy && sent == 0)
+ 	_busy_returns++;
+ 
+ #if HAVE_LINUX_POLLING
+     if (is_polling) {
+ 	if (busy && sent == 0) {
+ 	    _dev_idle++;
+ 	    if (_dev_idle == 1024) {
+ 		/* device didn't send anything, ping it */
+ 		_dev->tx_start(_dev);
+ 		_dev_idle = 0;
+ 		_hard_start++;
+ 	    }
+ 	} else
+ 	    _dev_idle = 0;
+     }
+ #endif
+ 
+ #if LINUX_VERSION_CODE >= 0x020400
+ # if HAVE_NETIF_TX_LOCK
+     //netif_tx_unlock_bh(_dev);
+ # else
+     //_dev->xmit_lock_owner = -1;
+     //spin_unlock(&_dev->xmit_lock);
+     //    local_bh_enable();
+ # endif
+ #endif
+     _dev->unlock_queue(_dev,&_queue,smp_processor_id());
+     // If we're polling, never go to sleep! We're relying on SubToDevice to clean
+     // the transmit ring.
+     // Otherwise, don't go to sleep if the signal isn't active and
+     // we didn't just send any packets
+ #if HAVE_CLICK_KERNEL_TX_NOTIFY
+     bool reschedule = (!busy && (sent > 0 || _signal.active()));
+ #else 
+     bool reschedule = (busy || sent > 0 || _signal.active());
+ #endif
+     
+ #if HAVE_LINUX_POLLING
+     if (is_polling) {
+ 	// 8.Dec.07: Do not recycle skbs until after unlocking the device, to
+ 	// avoid deadlock.  After initial patch by Joonwoo Park.
+ 	if (clean_skbs) {
+ # if CLICK_DEVICE_STATS
+ 	    if (_activations > 1)
+ 		GET_STATS_RESET(low00, low10, time_now, 
+ 				_perfcnt1_clean, _perfcnt2_clean, _time_clean);
+ # endif
+ 	    skbmgr_recycle_skbs(clean_skbs);
+ # if CLICK_DEVICE_STATS
+ 	    if (_activations > 1)
+ 		GET_STATS_RESET(low00, low10, time_now, 
+ 				_perfcnt1_freeskb, _perfcnt2_freeskb, _time_freeskb);
+ # endif
+ 	}
+ 
+ 	reschedule = true;
+ 	// 9/18/06: Frederic Van Quickenborne reports (1/24/05) that ticket
+ 	// adjustments in FromDevice+SubToDevice cause odd behavior.  The ticket
+ 	// adjustments actually don't feel necessary to me in From/SubToDevice
+ 	// any more, as described in FromDevice.  So adjusting tickets now
+ 	// only if polling.
+ 	adjust_tickets(sent);
+     }
+ #endif /* HAVE_LINUX_POLLING */
+ 
+     // 5.Feb.2007: Incorporate a version of a patch from Jason Park.  If the
+     // device is "busy", perhaps there is no carrier!  Don't spin on no
+     // carrier; instead, rely on Linux's notifer_hook to wake us up again.
+     if (busy && sent == 0 && !netif_carrier_ok(_dev))
+ 	reschedule = false;
+     
+     if (reschedule)
+ 	_task.fast_reschedule();
+     return sent > 0;
+     }
+     else
+ 	{
+ 	    
+ 	    _task.fast_reschedule();
+ 	    //lick_chatter("returning early\n");
+ 	    return false;
+ 
+ 	}
+     
+ }
+ 
+ int
+ SubToDevice::queue_packet(Packet *p)
+ {
+     struct sk_buff *skb1 = p->skb();
+   
+     /*
+      * Ensure minimum ethernet packet size (14 hdr + 46 data).
+      * I can't figure out where Linux does this, so I don't
+      * know the correct procedure.
+      */
+     int need_tail = 60 - p->length();
+ 
+     if (!_no_pad && need_tail > 0) {
+ 	if (skb_tailroom(skb1) < need_tail) {
+ 	    if (++_too_short == 1)
+ 		printk("<1>SubToDevice %s packet too small (len %d, tailroom %d, need %d), had to copy\n", _dev->name, skb1->len, skb_tailroom(skb1), need_tail);
+ 	    struct sk_buff *nskb = skb_copy_expand(skb1, skb_headroom(skb1), skb_tailroom(skb1) + 60 - skb1->len, GFP_ATOMIC);
+ 	    kfree_skb(skb1);
+ 	    if (!nskb)
+ 		return -1;
+ 	    skb1 = nskb;
+ 	}
+ 	// printk("padding %d:%d:%d\n", skb1->truesize, skb1->len, 60-skb1->len);
+ 	skb_put(skb1, need_tail);
+     }
+ 
+     // set the device annotation;
+     // apparently some devices in Linux 2.6 require it
+     skb1->dev = _dev;
+     
+     int ret;
+ #if HAVE_LINUX_POLLING
+     if (_dev->polling > 0)
+ 	ret = _dev->tx_pqueue(_dev, &_queue, skb1);
+     else
+ #endif
+ 	{
+ 	    ret = _dev->hard_start_xmit(skb1, _dev);
+ 	    _hard_start++;
+ 	}
+     if (ret != 0) {
+ 	if (++_rejected == 1)
+ 	    printk("<1>SubToDevice %s rejected a packet!\n", _dev->name);
+ 	kfree_skb(skb1);
+     }
+     return ret;
+ }
+ 
+ void
+ SubToDevice::change_device(net_device *dev)
+ {
+     bool dev_change = _dev != dev;
+ 
+     if (dev_change)
+ 	_task.strong_unschedule();
+     
+     set_device(dev, &to_device_map, true);
+ 
+     if (dev_change && _dev)
+ 	_task.strong_reschedule();
+ }
+ 
+ extern "C" {
+ static int
+ device_notifier_hook(struct notifier_block *nb, unsigned long flags, void *v)
+ {
+ #ifdef NETDEV_GOING_DOWN
+     if (flags == NETDEV_GOING_DOWN)
+ 	flags = NETDEV_DOWN;
+ #endif
+     if (flags == NETDEV_DOWN || flags == NETDEV_UP || flags == NETDEV_CHANGE) {
+ 	bool exists = (flags != NETDEV_UP);
+ 	net_device *dev = (net_device *)v;
+ 	Vector<AnyDevice *> es;
+ 	to_device_map.lock(true);
+ 	to_device_map.lookup_all(dev, exists, es);
+ 	for (int i = 0; i < es.size(); i++)
+ 	    ((SubToDevice *)(es[i]))->change_device(flags == NETDEV_DOWN ? 0 : dev);
+ 	to_device_map.unlock(true);
+     }
+     return 0;
+ }
+ }
+ 
+ static String
+ SubToDevice_read_calls(Element *f, void *)
+ {
+     SubToDevice *td = (SubToDevice *)f;
+     return
+ 	String(td->_rejected) + " packets rejected\n" +
+ 	String(td->_hard_start) + " hard start xmit\n" +
+ 	String(td->_busy_returns) + " device busy returns\n" +
+ 	String(td->_npackets) + " packets sent\n" +
+ 	String(td->_runs) + " calls to run_task()\n" +
+ 	String(td->_pulls) + " pulls\n" +
+ #if CLICK_DEVICE_STATS
+ 	String(td->_pull_cycles) + " cycles pull\n" +
+ 	String(td->_time_clean) + " cycles clean\n" +
+ 	String(td->_time_freeskb) + " cycles freeskb\n" +
+ 	String(td->_time_queue) + " cycles queue\n" +
+ 	String(td->_perfcnt1_pull) + " perfctr1 pull\n" +
+ 	String(td->_perfcnt1_clean) + " perfctr1 clean\n" +
+ 	String(td->_perfcnt1_freeskb) + " perfctr1 freeskb\n" +
+ 	String(td->_perfcnt1_queue) + " perfctr1 queue\n" +
+ 	String(td->_perfcnt2_pull) + " perfctr2 pull\n" +
+ 	String(td->_perfcnt2_clean) + " perfctr2 clean\n" +
+ 	String(td->_perfcnt2_freeskb) + " perfctr2 freeskb\n" +
+ 	String(td->_perfcnt2_queue) + " perfctr2 queue\n" +
+ 	String(td->_activations) + " transmit activations\n"
+ #else
+ 	String()
+ #endif
+ 	;
+ }
+ 
+ enum { H_COUNT, H_DROPS, H_PULL_CYCLES, H_TIME_QUEUE, H_TIME_CLEAN };
+ 
+ static String
+ SubToDevice_read_stats(Element *e, void *thunk)
+ {
+     SubToDevice *td = (SubToDevice *)e;
+     switch ((uintptr_t) thunk) {
+       case H_COUNT:
+ 	return String(td->_npackets);
+       case H_DROPS:
+ 	return String(td->_rejected);
+ #if CLICK_DEVICE_THESIS_STATS || CLICK_DEVICE_STATS
+       case H_PULL_CYCLES:
+ 	return String(td->_pull_cycles);
+ #endif
+ #if CLICK_DEVICE_STATS
+       case H_TIME_QUEUE:
+ 	return String(td->_time_queue);
+       case H_TIME_CLEAN:
+ 	return String(td->_time_clean);
+ #endif
+       default:
+ 	return String();
+     }
+ }
+ 
+ static int
+ SubToDevice_write_stats(const String &, Element *e, void *, ErrorHandler *)
+ {
+   SubToDevice *td = (SubToDevice *)e;
+   td->reset_counts();
+   return 0;
+ }
+ 
+ void
+ SubToDevice::add_handlers()
+ {
+     add_read_handler("calls", SubToDevice_read_calls, 0);
+     add_read_handler("count", SubToDevice_read_stats, (void *)H_COUNT);
+     add_read_handler("drops", SubToDevice_read_stats, (void *)H_DROPS);
+     // XXX deprecated
+     add_read_handler("packets", SubToDevice_read_stats, (void *)H_COUNT);
+ #if CLICK_DEVICE_THESIS_STATS || CLICK_DEVICE_STATS
+     add_read_handler("pull_cycles", SubToDevice_read_stats, (void *)H_PULL_CYCLES);
+ #endif
+ #if CLICK_DEVICE_STATS
+     add_read_handler("enqueue_cycles", SubToDevice_read_stats, (void *)H_TIME_QUEUE);
+     add_read_handler("clean_dma_cycles", SubToDevice_read_stats, (void *)H_TIME_CLEAN);
+ #endif
+     add_write_handler("reset_counts", SubToDevice_write_stats, 0, Handler::BUTTON);
+     add_task_handlers(&_task);
+ }
+ 
+ ELEMENT_REQUIRES(AnyDevice linuxmodule)
+ EXPORT_ELEMENT(SubToDevice)
*** click-git-20080715.orig/elements/linuxmodule/subtodevice.hh	1970-01-01 01:00:00.000000000 +0100
--- click-git-20080715/elements/linuxmodule/subtodevice.hh	2009-04-23 15:38:28.000000000 +0100
***************
*** 0 ****
--- 1,176 ----
+ #ifndef CLICK_SUBTODEVICE_HH
+ #define CLICK_SUBTODEVICE_HH
+ 
+ /*
+ =c
+ 
+ ToDevice(DEVNAME [, BURST, I<KEYWORDS>])
+ 
+ =s netdevices
+ 
+ sends packets to network device (Linux kernel)
+ 
+ =d
+ 
+ This manual page describes the Linux kernel module version of the ToDevice
+ element. For the user-level element, read the ToDevice.u manual page.
+ 
+ Pulls packets from its single input and sends them out the Linux network
+ interface named DEVNAME. DEVNAME may also be an Ethernet address, in which
+ case ToDevice searches for a device with that address.
+ 
+ Sends up to BURST packets each time it is scheduled. By default, BURST is 16.
+ For good performance, you should set BURST to be 8 times the number of
+ elements that could generate packets for this device.
+ 
+ Packets must have a link header. For Ethernet, ToDevice makes sure every
+ packet is at least 60 bytes long (but see NO_PAD).
+ 
+ Keyword arguments are:
+ 
+ =over 8
+ 
+ =item BURST
+ 
+ Unsigned integer. Same as the BURST argument.
+ 
+ =item QUIET
+ 
+ Boolean.  If true, then suppress device up/down messages.  Default is false.
+ 
+ =item ALLOW_NONEXISTENT
+ 
+ Allow nonexistent devices. If true, and no device named DEVNAME exists when
+ the router is initialized, then ToDevice will report a warning (rather than an
+ error). Later, while the router is running, if a device named DEVNAME appears,
+ ToDevice will seamlessly begin sending packets to it. Default is false.
+ 
+ =item NO_PAD
+ 
+ Boolean. If true, don't force packets to be at least 60 bytes (the
+ minimum Ethernet packet size).  This is useful because some 802.11
+ cards can send shorter Ethernet format packets.  Defaults false.
+ 
+ =item UP_CALL
+ 
+ Write handler.  If supplied, this handler is called when the device or link
+ comes up.
+ 
+ =item DOWN_CALL
+ 
+ Write handler.  If supplied, this handler is called when the device or link
+ goes down.
+ 
+ =back
+ 
+ =n
+ 
+ The Linux networking code may also send packets out the device. If the device
+ is in polling mode, Click will try to ensure that Linux eventually sends its
+ packets. Linux may cause the device to be busy when a ToDevice wants to send a
+ packet. Click is not clever enough to re-queue such packets, and discards
+ them.
+ 
+ In Linux 2.2, whether or not the device is running in polling mode, ToDevice
+ depends on the device driver's send operation for synchronization (e.g. tulip
+ send operation uses a bit lock). In Linux 2.4, we use the device's "xmit_lock"
+ to synchronize.
+ 
+ Packets sent via ToDevice will not be received by any packet sniffers on the
+ machine. Use Tee and ToHostSniffers to send packets to sniffers explicitly.
+ 
+ =h count read-only
+ 
+ Returns the number of packets ToDevice has pulled.
+ 
+ =h calls read-only
+ 
+ Returns a summary of ToDevice statistics.
+ 
+ =h drops read-only
+ 
+ Returns the number of packets ToDevice has dropped.  ToDevice will drop
+ packets because they are too short for the device, or because the device
+ explicitly rejected them.
+ 
+ =h reset_counts write-only
+ 
+ Resets counters to zero when written.
+ 
+ =a FromDevice, PollDevice, FromHost, ToHost, ToDevice.u, Tee, ToHostSniffers
+ 
+ */
+ 
+ #include "elements/linuxmodule/anydevice.hh"
+ #include "elements/linuxmodule/todevice.hh"
+ #include <click/notifier.hh>
+ 
+ class SubToDevice : public ToDevice { public:
+   
+   SubToDevice();
+   ~SubToDevice();
+ 
+   static void static_initialize();
+   static void static_cleanup();
+   
+   const char *class_name() const	{ return "SubToDevice"; }
+   const char *port_count() const	{ return PORTS_1_0; }
+   const char *processing() const	{ return PULL; }
+   
+   int configure_phase() const		{ return CONFIGURE_PHASE_TODEVICE + 1; }
+   int configure(Vector<String> &, ErrorHandler *);
+   int initialize(ErrorHandler *);
+   void cleanup(CleanupStage);
+   void add_handlers();
+   
+   bool run_task(Task *);
+ 
+   void reset_counts();
+   inline void tx_wake_queue(net_device *);
+   bool tx_intr();
+   void change_device(net_device *);
+ 
+ #if CLICK_DEVICE_STATS
+   // Statistics.
+   uint64_t _time_clean;
+   uint64_t _time_freeskb;
+   uint64_t _time_queue;
+   uint64_t _perfcnt1_pull;
+   uint64_t _perfcnt1_clean;
+   uint64_t _perfcnt1_freeskb;
+   uint64_t _perfcnt1_queue;
+   uint64_t _perfcnt2_pull;
+   uint64_t _perfcnt2_clean;
+   uint64_t _perfcnt2_freeskb;
+   uint64_t _perfcnt2_queue;
+   uint32_t _activations; 
+ #endif
+   uint32_t _runs;
+   uint32_t _pulls;
+   uint32_t _npackets;
+ #if CLICK_DEVICE_THESIS_STATS || CLICK_DEVICE_STATS
+   click_cycles_t _pull_cycles;
+ #endif
+   uint32_t _rejected;
+   uint32_t _hard_start;
+   uint32_t _busy_returns;
+   uint32_t _too_short;
+ 
+ #if HAVE_LINUX_POLLING
+   bool polling() const			{ return _dev && _dev->polling > 0; }
+ #else
+   bool polling() const			{ return false; }
+ #endif
+   
+  private:
+ 
+   unsigned _burst;
+   int _dev_idle;
+   NotifierSignal _signal;
+   bool _no_pad;
+   
+   int queue_packet(Packet *p);
+   
+ };
+ 
+ #endif
*** click-git-20080715.orig/elements/linuxmodule/todevice.cc	2009-04-30 15:51:25.000000000 +0100
--- click-git-20080715/elements/linuxmodule/todevice.cc	2009-04-30 12:46:04.000000000 +0100
***************
*** 118,123 ****
--- 118,124 ----
  ToDevice::configure(Vector<String> &conf, ErrorHandler *errh)
  {
      _burst = 16;
+     _queue = 0;
      if (AnyDevice::configure_keywords(conf, errh, false) < 0
  	|| cp_va_kparse(conf, this, errh,
  			"DEVNAME", cpkP+cpkM, cpString, &_devname,
***************
*** 141,149 ****
      // check for duplicate writers
      if (ifindex() >= 0) {
  	void *&used = router()->force_attachment("device_writer_" + String(ifindex()));
! 	if (used)
! 	    return errh->error("duplicate writer for device '%s'", _devname.c_str());
! 	used = this;
      }
  
  #if HAVE_CLICK_KERNEL_TX_NOTIFY
--- 142,150 ----
      // check for duplicate writers
      if (ifindex() >= 0) {
  	void *&used = router()->force_attachment("device_writer_" + String(ifindex()));
! 	//if (used)
! 	//    return errh->error("duplicate writer for device '%s'", _devname.c_str());
! 	//used = this;
      }
  
  #if HAVE_CLICK_KERNEL_TX_NOTIFY
***************
*** 162,168 ****
      _max_tickets = _task.tickets();
      _task.set_tickets(Task::DEFAULT_TICKETS);
  #endif
! 
      reset_counts();
      return 0;
  }
--- 163,169 ----
      _max_tickets = _task.tickets();
      _task.set_tickets(Task::DEFAULT_TICKETS);
  #endif
!     _dev->unlock_queue(_dev,&_queue,smp_processor_id());
      reset_counts();
      return 0;
  }
***************
*** 229,242 ****
  
  #if LINUX_VERSION_CODE >= 0x020400
  # if HAVE_NETIF_TX_LOCK
!     int ok = spin_trylock_bh(&_dev->_xmit_lock);
!     if (likely(ok))
! 	_dev->xmit_lock_owner = smp_processor_id();
!     else {
! 	_task.fast_reschedule();
! 	return false;
!     }
  # else
      local_bh_disable();
      if (!spin_trylock(&_dev->xmit_lock)) {
  	local_bh_enable();
--- 230,241 ----
  
  #if LINUX_VERSION_CODE >= 0x020400
  # if HAVE_NETIF_TX_LOCK
!     int ok = _dev->lock_queue(_dev,&_queue,smp_processor_id());
! 	//spin_trylock_bh(&_dev->priv->tx_ring[_queue]->_xmit_lock);
!     if (likely(ok)) {
! 
  # else
+ 
      local_bh_disable();
      if (!spin_trylock(&_dev->xmit_lock)) {
  	local_bh_enable();
***************
*** 257,263 ****
      bool is_polling = (_dev->polling > 0);
      struct sk_buff *clean_skbs;
      if (is_polling)
! 	clean_skbs = _dev->tx_clean(_dev);
      else
  	clean_skbs = 0;
  #endif
--- 256,262 ----
      bool is_polling = (_dev->polling > 0);
      struct sk_buff *clean_skbs;
      if (is_polling)
! 	clean_skbs = _dev->tx_clean(_dev,&_queue);
      else
  	clean_skbs = 0;
  #endif
***************
*** 332,345 ****
  
  #if LINUX_VERSION_CODE >= 0x020400
  # if HAVE_NETIF_TX_LOCK
!     netif_tx_unlock_bh(_dev);
  # else
!     _dev->xmit_lock_owner = -1;
!     spin_unlock(&_dev->xmit_lock);
!     local_bh_enable();
  # endif
  #endif
! 
      // If we're polling, never go to sleep! We're relying on ToDevice to clean
      // the transmit ring.
      // Otherwise, don't go to sleep if the signal isn't active and
--- 331,346 ----
  
  #if LINUX_VERSION_CODE >= 0x020400
  # if HAVE_NETIF_TX_LOCK
!     // _dev->unlock_queue(_dev,&_queue,smp_processor_id());
!     //netif_tx_unlock_bh(_dev);
  # else
!     //_dev->unlock_queue(_dev,&_queue,smp_processor_id());
!     //_dev->xmit_lock_owner = -1;
!     //spin_unlock(&_dev->xmit_lock);
!     //local_bh_enable();
  # endif
  #endif
!     _dev->unlock_queue(_dev,&_queue,smp_processor_id());
      // If we're polling, never go to sleep! We're relying on ToDevice to clean
      // the transmit ring.
      // Otherwise, don't go to sleep if the signal isn't active and
***************
*** 387,392 ****
--- 388,399 ----
      if (reschedule)
  	_task.fast_reschedule();
      return sent > 0;
+     }
+     else {
+ 	_task.fast_reschedule();
+ 	//lick_chatter("returning early\n");
+ 	return false;
+     }
  }
  
  int
***************
*** 421,431 ****
      
      int ret;
  #if HAVE_LINUX_POLLING
      if (_dev->polling > 0)
! 	ret = _dev->tx_queue(_dev, skb1);
      else
  #endif
  	{
  	    ret = _dev->hard_start_xmit(skb1, _dev);
  	    _hard_start++;
  	}
--- 428,443 ----
      
      int ret;
  #if HAVE_LINUX_POLLING
+     //click_chatter("polling testing %d\n",_dev->polling);
      if (_dev->polling > 0)
! 	{
! 	    //    click_chatter("tx_mqueue called for queue %d\n",_queue);
! 	    ret = _dev->tx_pqueue(_dev, &_queue, skb1);
! 	}
      else
  #endif
  	{
+ 	    //click_chatter("hard start xmit called for queue %d\n",_queue);
  	    ret = _dev->hard_start_xmit(skb1, _dev);
  	    _hard_start++;
  	}
*** click-git-20080715.orig/elements/linuxmodule/todevice.hh	2009-04-30 15:51:25.000000000 +0100
--- click-git-20080715/elements/linuxmodule/todevice.hh	2009-04-23 15:38:28.000000000 +0100
***************
*** 161,174 ****
    bool polling() const			{ return false; }
  #endif
    
!  private:
  
    unsigned _burst;
    int _dev_idle;
    NotifierSignal _signal;
    bool _no_pad;
!   
    int queue_packet(Packet *p);
    
  };
  
--- 161,176 ----
    bool polling() const			{ return false; }
  #endif
    
!  protected:
  
    unsigned _burst;
    int _dev_idle;
    NotifierSignal _signal;
    bool _no_pad;
!   int _queue;
    int queue_packet(Packet *p);
+ 
+  private:
    
  };
